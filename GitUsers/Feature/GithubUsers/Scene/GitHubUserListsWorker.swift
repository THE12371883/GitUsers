//
//  GitHubUserListsWorker.swift
//  GitUsers
//
//  Created by Teravat Nepiyachat on 5/4/2564 BE.
//  Copyright (c) 2564 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol IGitHubUserListsWorker {
	func getGitHubUsers(completion: @escaping (Result<[IGitHubUserListsModel], Error>) -> Void)
	func setFavoriteUser(with id: Int, completion: @escaping () -> Void)
	func getGithubUserDetail(at index: Int, completion: @escaping (IGitHubUserListsModel) -> Void)
	func fetchGithubUsersData() -> [IGitHubUserListsModel]
	func setFavoriteFilter(isActive: Bool, completion: @escaping ([IGitHubUserListsModel]) -> Void)
	func setSort(sortType: SortType, completion: @escaping ([IGitHubUserListsModel]) -> Void)
	func sortGitHubUsers(datas: [IGitHubUserListsModel]) -> [IGitHubUserListsModel]
	func getGitHubSearchUsers(with searchText: String, completion: @escaping (Result<[IGitHubUserListsModel], Error>) -> Void)
}

class GitHubUserListsWorker {
	let githubAPIService: IGitHubAPIService
	let reamlService: IRealmService
	var inMemoryStore: IGitHubUserListsInMemoryStore
	
	init(githubAPIService: IGitHubAPIService,
		 reamlService: IRealmService,
		 inMemoryStore: IGitHubUserListsInMemoryStore) {
		self.githubAPIService = githubAPIService
		self.reamlService = reamlService
		self.inMemoryStore = inMemoryStore
	}
}

// MARK: - IGitHubUserListsWorker

extension GitHubUserListsWorker: IGitHubUserListsWorker {
	func getGitHubUsers(completion: @escaping (Result<[IGitHubUserListsModel], Error>) -> Void) {
		inMemoryStore.sortType = .default
		inMemoryStore.isFavoriteFilterActive = false
		githubAPIService.getGitHubUsers { result in
			switch result {
			case .success(let datas):
				self.inMemoryStore.gitHubUserListsModel = datas
				let models = self.fetchGithubUsersData()
				completion(.success(models))
			case .failure(let error):
				completion(.failure(error))
			}
		}
	}
	
	func setFavoriteUser(with id: Int, completion: @escaping () -> Void) {
		reamlService.insertFavoriteUserToRealm(withId: id) {
			completion()
		}
	}
	
	func fetchGithubUsersData() -> [IGitHubUserListsModel] {
		for index in 0..<inMemoryStore.gitHubUserListsModel.count {
			reamlService.queryFavoriteUserWithIdFromRealm(withId: inMemoryStore.gitHubUserListsModel[index].id ?? 0) { result in
				self.inMemoryStore.gitHubUserListsModel[index].favoriteStatus = result
			}
		}
		
		var data = inMemoryStore.gitHubUserListsModel
		
		if inMemoryStore.isFavoriteFilterActive {
			data = inMemoryStore.gitHubUserListsModel.filter { $0.favoriteStatus == inMemoryStore.isFavoriteFilterActive }
		} else {
			data = inMemoryStore.gitHubUserListsModel
		}
		
		data = self.sortGitHubUsers(datas: data)
		
		return data
	}
	
	func getGithubUserDetail(at index: Int, completion: @escaping (IGitHubUserListsModel) -> Void) {
		let gitHubUserListsModel = self.fetchGithubUsersData()
		completion(gitHubUserListsModel[index])
	}
	
	func setFavoriteFilter(isActive: Bool, completion: @escaping ([IGitHubUserListsModel]) -> Void) {
		inMemoryStore.isFavoriteFilterActive = isActive
		let data = fetchGithubUsersData()
		completion(data)
	}
	
	func setSort(sortType: SortType, completion: @escaping ([IGitHubUserListsModel]) -> Void) {
		inMemoryStore.sortType = sortType
		let data = fetchGithubUsersData()
		completion(data)
	}
	
	func sortGitHubUsers(datas: [IGitHubUserListsModel]) -> [IGitHubUserListsModel] {
		
		switch inMemoryStore.sortType {
		case .alphabetAscending:
			let data = datas.sorted(by: { ($0.loginName ?? "").localizedStandardCompare(($1.loginName ?? "")) == .orderedAscending })
			return data
		case .alphabetDescending:
			let data = datas.sorted(by: { ($0.loginName ?? "").localizedStandardCompare(($1.loginName ?? "")) == .orderedDescending })
			return data
		case .default:
			let data = datas
			return data
		}
	}
	
	func getGitHubSearchUsers(with searchText: String, completion: @escaping (Result<[IGitHubUserListsModel], Error>) -> Void) {
		inMemoryStore.sortType = .default
		inMemoryStore.isFavoriteFilterActive = false
		githubAPIService.getGitHubSearchUsers(with: ["q": searchText]) { result in
			switch result {
			case .success(let datas):
				self.inMemoryStore.gitHubUserListsModel = datas
				let models = self.fetchGithubUsersData()
				completion(.success(models))
			case .failure(let error):
				completion(.failure(error))
			}
		}
	}
}
